// PiPLa0601.cpp
/***********************************************************
PiPLa0601. Sastâdît C++ programmu, kas izdzçð no dotâs skaitïu virknes lietotâja dotu skaitli.
Skaitïu virkne jârealizç kâ vienvirziena saistîtais saraksts,
izveidojot klases Node un List
(var izmantot e-kursa piemçru linked_list_class.cpp).
************************************************************/
// Autors: Uldis Straujums (modificçts linked_list_class.cpp)
// Radîts: 01.04.2019. Izmantots PiPLa0302.cpp, mezgla izdzçðana pârveidota par metodi deleteNode


#include <iostream>
#include "lvtocon.h" // latvieðu valodas tekstu izvadei projektos v.2.0(Çriks Gopaks, 2011)
using namespace std;

// Klase Node - saraksta mezgls ar
// elementu - vesels skaitlis
class Node
{
public:
int num;
Node* next;
Node (int n) { num = n; next = NULL; };
};
// Klase List - saistîts vienvirziena saraksts ar
// elementu - vesels skaitïis
class List
{
protected:
 Node *first, *last;
public:
 Node *current;
public:
 /** Konstruktora metode List() izveido tukðu sarakstu **/
 List ();
 /** Metode add_element(n) pievieno elementu n saraksta beigâs **/
 void add_element (int n);
 /** Metode delete_element() izdzçð elementu no saraksta sâkuma **/
 void delete_element ();
 /** Metode is_empty() noskaidro, vai saraksts ir tukðs **/
 bool is_empty ();
 /** Metode start() uzstâda râdîtâju current uz saraksta sâkumu **/
 void start ();
 /** Metode end() noskaidro, vai râdîtâjs current ir nonâcis aiz saraksta beigâm **/
 bool end ();
 /** Metode next() uzstâda râdîtâju current uz saraksta nâkamo elementu **/
 void next();
// Metodes, kas pieliktas linked_list_class.cpp
/** metode print() izdrukâ sarakstu **/
void print();
/** metode ~List() atbrîvo visu mezglu dinamiski pieprasîto atmiòu **/
~List();
/** metode deleteNode(i) izdzçð pirmo mezglu ar vçrtîbu i,
     atgrieþ false, ja nav atrasts mezgls ar vçrtîbu i **/
 bool deleteNode(int i);
};

int main ()
{
int i;
int sk; // izdzçðamais skaitlis
List s;

// Saraksta s elementu ievadîðanai tiek lietota
// tâda pat shçma kâ teksta failu secîgai lasîðanai
cout << "Ievadiet saraksta elementu, lai beigtu, ievadiet 0:" << endl;
cin >> i;
// ievadîðana, kamçr nav sastapta 0
while (i != 0)
{
s.add_element(i);
cout << "Ievadiet saraksta elementu, lai beigtu, ievadiet 0:" << endl;
cin >> i;
};
// saraksta izdruka
s.print();

// izdzçðamâ skaitïa dabûðana
cout << "Ievadiet izdzçðamo skaitli:"<< endl;
cin >> sk;
// Izdzçð pirmo elementu ar vçrtîbu sk
if(s.deleteNode(sk))
    cout << "Elements "<<sk<< " izdzçsts"<<endl;
  else cout << "Nav elementa " << sk << endl;

/** Tâ var izdzçst visus elementus ar vçrtîbu sk
while(s.deleteNode(sk))
    cout << "Elements "<<sk<< " izdzçsts"<<endl;
**/
// saraksta izdruka
s.print();

// saraksta iznîcinâðana notiek, izpildot destruktoru
return 0;
}
/** Konstruktora metode List() izveido tukðu sarakstu **/
 List::List () { first = last = current = NULL; };
/** Metode add_element(n) pievieno elementu n saraksta beigâs **/
void List::add_element (int n)
{
 Node *p = new Node (n);
 if (first == NULL) first = last = p;
 else last = last -> next = p;
 current =p; // maina current vçrtîbu, lai râdîtu uz jauno elementu
};
/** Metode delete_element() izdzçð elementu no saraksta sâkuma **/
void List::delete_element ()
{ // saglabâ current vçrtîbu (nomaina uz saraksta jauno sâkumu, ja râdîja uz izmetamo)
 Node *p = first;
 if(!is_empty())
 { if (current == first) current = first-> next;
 first = first -> next;
 delete p;
 if(is_empty())last = NULL;
 }
};
/** Metode is_empty() noskaidro, vai saraksts ir tukðs **/
 bool List::is_empty () { return (first == NULL); };
 /** Metode start() uzstâda râdîtâju current uz saraksta sâkumu **/
 void List::start () { current = first; };
 /** Metode end() noskaidro, vai râdîtâjs current ir nonâcis aiz saraksta beigâm **/
 bool List::end () { return (current == NULL); };
 /** Metode next() uzstâda râdîtâju current uz saraksta nâkamo elementu **/
 void List::next(){if (!end())current = current -> next;};
 /** metode print() izdrukâ sarakstu **/
void List::print()
{
   for(start();!end();next())
    cout << current->num<< endl;
   cout << endl;
}
/** metode ~List() atbrîvo visu mezglu dinamiski pieprasîto atmiòu **/
List::~List()
{
    while (!is_empty())
 {
   delete_element();
 };
 cout << "Visu mezglu atmiòa ir atbrîvota"<< endl;
};
/** metode deleteNode(i) izdzçð pirmo mezglu ar vçrtîbu i,
     atgrieþ false, ja nav atrasts mezgls ar vçrtîbu i **/
bool List::deleteNode(int i)
{
    // skaitïa i izdzçðana no saraksta
Node* p;
Node* prev=NULL;
bool ir_izdzests=false;
for (p = first; p!=NULL; p=p->next)
{
if (p->num == i)
    {
    if (prev==NULL) // jâdzçð pirmais
    {
    first = p->next;
    if (p==last) last = NULL;
    delete p;
    ir_izdzests=true;
    return ir_izdzests;
    }
    else
       if (p==last) //jâdzçð pçdçjais
   {
       last = prev;
       prev->next=NULL;
       delete p;
       ir_izdzests=true;
       return ir_izdzests;
   }
       else // jâdzçð ne pirmais, ne pçdçjais
       {
        prev->next=p->next;
        delete p;
        ir_izdzests=true;
        return ir_izdzests;
       }
    }
else
    prev=p;
}
return ir_izdzests;
};
/**** Testu plâns *******************************************
saraksts      izdzçðamais skaitlis        paredzamais rezuultâts
1 2 3 3 2       3 (nepirmais, nepçdçjais) 1 2 3 2
=============================================================
3 2             3 (pirmais)               2
=============================================================
2 3             3 (pçdçjais)              2
=============================================================
3               3  (vienîgais)            tukðs
=============================================================
1 2 3 3 2       4  (nav sarakstâ)         1 2 3 3 2
=============================================================
2 3 4 2 2       2 (gan pirmais,           3 4
                   gan nepirmais,
                  gan pçdçjais)
=============================================================
tukðs           17                        tukðs
************************************************************/
